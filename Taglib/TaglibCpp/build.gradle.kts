import java.net.URI
import java.nio.file.Files

plugins {
    `cpp-library`
}

group = "apps.chocolatecakecodes.bluebeats.mpv.internal"
version = libs.versions.taglib

val dirCFiles = file("src/cpp")
val dirHFiles = file("src/headers")
val dirPrepFiles = file("src/config")

library {
    linkage = listOf(Linkage.STATIC)

    source.from(dirCFiles)
    privateHeaders.from(dirHFiles)
}

tasks.create("collectSources") {
    val taglibVersion = libs.versions.taglib.get()
    val utfcppVersion = libs.versions.utfcpp.get()

    group = "prepare"
    inputs.property("taglibVersion", taglibVersion)
    inputs.property("utfcppVersion", utfcppVersion)
    outputs.dirs(dirCFiles, dirHFiles)

    // clean dest
    doLast {
        dirCFiles.deleteRecursively()
        dirHFiles.deleteRecursively()

        dirCFiles.mkdir()
        dirHFiles.mkdir()
        project.layout.buildDirectory.dir("tmp").get().asFile.mkdir()
    }

    // download and extract Taglib
    // sort files for Gradle structure
    doLast {
        val taglibTar = project.layout.buildDirectory.file("tmp/taglib.tar.gz").get().asFile
        URI("https://github.com/taglib/taglib/releases/download/v$taglibVersion/taglib-$taglibVersion.tar.gz").toURL().openStream().use { tarIn ->
            Files.newOutputStream(taglibTar.toPath()).use { out ->
                tarIn.transferTo(out)
            }
        }

        val pathPrefix = "taglib-$taglibVersion/taglib/"
        copy {
            from(tarTree(taglibTar))
            into(dirCFiles)
            include("$pathPrefix/**/*.cpp")
            eachFile {
                this.relativePath = RelativePath(true, *relativePath.segments.drop(2).toTypedArray())
            }
        }
        copy {
            from(tarTree(taglibTar))
            into(dirHFiles)
            include("$pathPrefix/**/*.h", "$pathPrefix/**/*.tcc")
            eachFile {
                this.relativePath = RelativePath(true, *relativePath.segments.drop(2).toTypedArray())
            }
        }
    }

    // download and extract UTF8-CPP
    doLast {
        val utfcppTar = project.layout.buildDirectory.file("tmp/utfcpp.tar.gz").get().asFile
        URI("https://github.com/nemtrif/utfcpp/archive/refs/tags/v$utfcppVersion.tar.gz").toURL().openStream().use { tarIn ->
            Files.newOutputStream(utfcppTar.toPath()).use { out ->
                tarIn.transferTo(out)
            }
        }

        val pathPrefix = "utfcpp-$utfcppVersion/source/"
        copy {
            from(tarTree(utfcppTar))
            into(dirHFiles)
            include("$pathPrefix/**/*.*")
            eachFile {
                this.relativePath = RelativePath(true, *relativePath.segments.drop(2).toTypedArray())
            }
        }
    }

    // copy headers generated by a CMake run
    doLast {
        copy {
            from(dirPrepFiles)
            into(dirHFiles)
            include("config.h", "taglib_config.h")
        }
    }
}

tasks.withType<CppCompile> {
    dependsOn("collectSources")

    // tell the compiler to look into every dir for headers
    fileTree("src/headers").filter {
        it.parentFile.name != "headers"
    }.map {
        "-I" + it.parentFile.absolutePath
    }.distinct().let {
        this.compilerArgs.addAll(it)
    }

    this.compilerArgs.addAll("-DHAVE_CONFIG_H", "-DTAGLIB_STATIC", "-fPIC")
}
